/* autogenerated by Processing revision 1281 on 2022-04-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class sketch_2048 extends PApplet {

PFont font;
boolean lose;
int score, best;
Grid grid;


//Set up vars
 public void setup(){
  /* size commented out by preprocessor */;
  grid = new Grid();
  strokeWeight(0);
  font = createFont("Clear Sans Bold", 100);
  textFont(font);
  lose = false;
  score = 0;
  newEmptySquare(grid);
  newEmptySquare(grid);
}


//Run 2048
 public void draw(){
  if(score > best) best = score;
  background(0xFFF9F5E4);
  textAlign(LEFT, BASELINE);
  
  init();
  
  //Print Blocks on Screen
  for(int i=0;i<grid.sqr.size();i++){ grid.sqr.get(i).display(); }
  
  if(lose) gameover();
  
  checkBlocks();
}


//Move blocks when the key is pressed
 public void keyPressed(){
  //Disable keyboard input when game over
  if(lose){
    return;
  }
  if(key == 'w' || keyCode == UP){
    moveBlocks('u');
  }
  if(key == 'a' || keyCode == LEFT){
    moveBlocks('l');
  }
  if(key == 's' || keyCode == DOWN){
    moveBlocks('d');
  }
  if(key == 'd' || keyCode == RIGHT){
    moveBlocks('r');
  }
}


//Retry and New game buttons
 public void mousePressed(){
  if(mouseX > 475 && mouseY > 90 && mouseX < 600 && mouseY < 140){
    score = 0;
    setup();
  }
  if(lose && mouseX > 250 && mouseY > 420 && mouseX < 420 && mouseY < 470){
    score = 0;
    setup();
  }
}
//Blocks displayed to screen
class Block{
  int x, y, num;
  boolean isEmpty, notCombined;
  
  //Constructors
  Block(int X, int Y){x=X;y=Y;num=0;isEmpty=true;notCombined=true;}
  Block(Block a, int NUM, boolean bool){x=a.x;y=a.y;num=NUM;isEmpty=false;notCombined=bool;}
  Block(Block a, int NUM){x=a.x;y=a.y;num=NUM;isEmpty=false;notCombined=a.notCombined;}
  Block(Block a){
    x=a.x; y=a.y;
    if(PApplet.parseInt(random(500)) > 450)
      num = 4;
    else num = 2;
    isEmpty = false;
    notCombined = true;
  }
  
  //Display the block to the screen
   public void display(){
    if(num==0) return;
    fill(num*623%255,num*875%255,num*567%255);
    rect(x,y,125,125,5);
    if(num<8) fill(0xFF776E65);
    else fill(255);
    textAlign(CENTER, CENTER);
    textSize(62);
    text(num,x+62,y+50);
  }
  
  //For removing blocks from screen
   public void removeNum(){
    num=0;
    isEmpty=true;
  }
  
};


//Grid of grid.sqr on screen
//0->3 top row
class Grid{
  ArrayList<Block> sqr = new ArrayList<Block>();
  int b=160;
  Grid(){
    for(int i=0;i<4;i++){
      int a=60;
      for(int j=0;j<4;j++){
        sqr.add(new Block(a,b));
        a+=135;
      }
      b+=135;
    }
  }
};
//Initialize background and UI
 public void init(){
  //2048 Title Text
  fill(0xFF776E65);
  textSize(125);
  text("2048",75,125);
  
  //Boxes
  fill(0xFFBBADA0);
  rect(400,20,100,50,5);
  rect(525,20,100,50,5);
  fill(0xFF8F7A66);
  rect(475,90,150,50,5);
  
  //Text
  textSize(20);
  fill(0xFFEEE4DA);
  textAlign(CENTER,CENTER);
  text("Score",450,30);
  text("Best",575,30);
  textSize(25);
  fill(255);
  text("New Game",550,110);
  textSize(30);
  text(score,450,50);
  text(best,575,50);
  
  //Background Tile
  fill(0xFFBBADA0);
  rect(50, 150, 550, 550, 10);
  
  //Smaller Tiles
  fill(0xFFCDC1B4);
  for(int i=60;i<600;i+=135){
    for(int j=160;j<700;j+=135){
      rect(i,j,125,125,5);
    }
  }
}


//Display when there are no more available moves
 public void gameover(){
  blend(50,150,550,550,50,150,550,550,HARD_LIGHT);
  textAlign(LEFT, BASELINE);
  fill(0xFF776E65);
  text("Game Over!",175,370);
  fill(0xFF8F7A66);
  rect(250,420,170,50,5);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(30);
  text("Try Again",335,437);
}
//Check if a square on the grid is empty
//If empty, place a new square there
 public void newEmptySquare(Grid a){
    int b = PApplet.parseInt(random(16));
    while(!a.sqr.get(b).isEmpty){
      b = PApplet.parseInt(random(16));
    }
    a.sqr.set(a.sqr.indexOf(a.sqr.get(b)), new Block(a.sqr.get(b)));
}


//Sets all blocks in grid to combinable
 public void combinable(){
  for(int i=0;i<grid.sqr.size();i++) grid.sqr.get(i).notCombined = true;
}


//Move blocks on screen based off of key pressed
 public void moveBlocks(char a){
  combinable();
  boolean notMoved = true;
  switch(a){
    //Up
    case('u'):
      //Cycle from row 2 to 4
      for(int i=4;i<16;i++){
        if(grid.sqr.get(i).isEmpty) continue;
        //Check for all blocks above it
        for(int n=1;n<4;n++){
          if(i-4*n>=0){
            //If empty, move up one
            if(grid.sqr.get(i-4*n).isEmpty){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i-4*n)), new Block(grid.sqr.get(i-4*n), grid.sqr.get(i-4*(n-1)).num)); 
              grid.sqr.get(i-4*(n-1)).removeNum();
              notMoved = false;
            }
            //If not empty, check if numbers match and add
            else if((grid.sqr.get(i-4*n).num == grid.sqr.get(i-4*(n-1)).num) && (grid.sqr.get(i-4*n).notCombined && grid.sqr.get(i-4*(n-1)).notCombined)){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i-4*n)), new Block(grid.sqr.get(i-4*n), grid.sqr.get(i-4*n).num*2, false));
              score += grid.sqr.get(i-4*n).num;
              grid.sqr.get(i-4*(n-1)).removeNum();
              notMoved = false;
            }
            else break;
          }
        }
      }
      if(notMoved) return;
      newEmptySquare(grid);
      break;
      
    //Left
    case('l'):
      //Cycle from col 2 to 4
      for(int i=1;i<16;i++){
        if((i%4 == 0) || (grid.sqr.get(i).isEmpty))continue;
        for(int n=1;n<4;n++){
          if(n<=i%4){
            //If empty, move left one
            if(grid.sqr.get(i-n).isEmpty){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i-n)), new Block(grid.sqr.get(i-n), grid.sqr.get(i-n+1).num));
              grid.sqr.get(i-n+1).removeNum();
              notMoved = false;
            }
            //If not empty, check if numbers match and add
            else if((grid.sqr.get(i-n).num == grid.sqr.get(i-n+1).num) && (grid.sqr.get(i-n).notCombined && grid.sqr.get(i-n+1).notCombined)){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i-n)), new Block(grid.sqr.get(i-n), grid.sqr.get(i-n).num*2, false));
              score += grid.sqr.get(i-n).num;
              grid.sqr.get(i-n+1).removeNum();
              notMoved = false;
            }
            else break;
          }
        }
      }
      if(notMoved) return;
      newEmptySquare(grid);
      break;
      
    //Down
    case('d'):
      //Cycle from row 4 to 2
      for(int i=11;i>-1;i--){
        if(grid.sqr.get(i).isEmpty) continue;
        //Check for all blocks below it
        for(int n=1;n<4;n++){
          if(i+4*n<=15){
            //If empty, move down one
            if(grid.sqr.get(i+4*n).isEmpty){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i+4*n)), new Block(grid.sqr.get(i+4*n), grid.sqr.get(i+4*(n-1)).num)); 
              grid.sqr.get(i+4*(n-1)).removeNum();
              notMoved = false;
            }
            //If not empty, check if numbers match and add
            else if((grid.sqr.get(i+4*n).num == grid.sqr.get(i+4*(n-1)).num) && (grid.sqr.get(i+4*n).notCombined && grid.sqr.get(i+4*(n-1)).notCombined)){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i+4*n)), new Block(grid.sqr.get(i+4*n), grid.sqr.get(i+4*n).num*2, false));
              score += grid.sqr.get(i+4*n).num;
              grid.sqr.get(i+4*(n-1)).removeNum();
              notMoved = false;
            }
            else break;
          }
        }
      }
      if(notMoved) return;
      newEmptySquare(grid);
      break;
    
    //Right
    case('r'):
      //Cycle from col 3 to 1
      for(int i=14;i>-1;i--){
        if((i%4==3) || (grid.sqr.get(i).isEmpty)) continue;
        //Check all blocks to the right of it
        for(int n=1;n<4;n++){
          if((4-n)>i%4){
            //If empty, move one right
            if(grid.sqr.get(i+n).isEmpty){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i+n)), new Block(grid.sqr.get(i+n), grid.sqr.get(i+n-1).num));
              grid.sqr.get(i+n-1).removeNum();
              notMoved = false;
            }
            //If not empty, check if numbers match and add
            else if((grid.sqr.get(i+n).num == grid.sqr.get(i+n-1).num) && (grid.sqr.get(i+n).notCombined && grid.sqr.get(i+n-1).notCombined)){
              grid.sqr.set(grid.sqr.indexOf(grid.sqr.get(i+n)), new Block(grid.sqr.get(i+n), grid.sqr.get(i+n).num*2, false));
              score += grid.sqr.get(i+n).num*2;
              grid.sqr.get(i+n-1).removeNum();
              notMoved = false;
            }
            else break;
          }
        }
      }
      if(notMoved) return;
      newEmptySquare(grid);
      break;
  }
}


//Check if there are no available moves
 public void checkBlocks(){
  int a=0;
  for(int i=0;i<16;i++){
    if(grid.sqr.get(i).isEmpty) continue;
    int num = grid.sqr.get(i).num;
    switch(i%4){
      //First col
      case(0):
        if(i<4){if((num != grid.sqr.get(i+1).num) && (num != grid.sqr.get(i+4).num)) a++;}
        else if(i>11){if((num != grid.sqr.get(i+1).num) && (num != grid.sqr.get(i-4).num)) a++;}
        else{if((num != grid.sqr.get(i+1).num) && (num != grid.sqr.get(i+4).num) && (num != grid.sqr.get(i-4).num)) a++;}
        break;
        
      //Last col
      case(3):
        if(i<4){if((num != grid.sqr.get(i-1).num) && (num != grid.sqr.get(i+4).num)) a++;}
        else if(i>11){if((num != grid.sqr.get(i-1).num)&& (num != grid.sqr.get(i-4).num)) a++;}
        else{if((num != grid.sqr.get(i-1).num) && (num != grid.sqr.get(i+4).num) && (num != grid.sqr.get(i-4).num)) a++;}
        break;
      
      //Middle cols
      default:
        if(i<4){if((num != grid.sqr.get(i+1).num) && (num != grid.sqr.get(i-1).num) && (num != grid.sqr.get(i+4).num)) a++;}
        else if(i>11){if((num != grid.sqr.get(i+1).num) && (num != grid.sqr.get(i-1).num) && (num != grid.sqr.get(i-4).num)) a++;}
        else{if((num != grid.sqr.get(i+1).num) && (num != grid.sqr.get(i-1).num) && (num != grid.sqr.get(i+4).num) && (num != grid.sqr.get(i-4).num)) a++;}
        break;
    }
  }
  if(a==16) lose=true;
}


  public void settings() { size(650, 750); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "sketch_2048" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
